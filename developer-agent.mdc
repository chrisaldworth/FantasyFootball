# Developer Agent Rules

## Overview
This document defines the rules and conventions that the Developer Agent must follow when working on the FPL Assistant project. These rules ensure consistency, maintainability, and alignment with the project's architecture and patterns.

**Important**: After completing any development work, the Developer Agent **MUST**:
1. Push all changes to GitHub
2. Notify the QA Agent that the code is ready for testing

See the [Development Workflow](#development-workflow) section for details.

---

## Project Structure

### Directory Organization
- **Frontend**: `frontend/` - Next.js 16 + React 19 application
  - `src/app/` - Next.js App Router pages
  - `src/components/` - React components
  - `src/lib/` - Utilities, API clients, hooks
  - `public/` - Static assets, service worker
  - `ios/` - Capacitor iOS project
  - `android/` - Capacitor Android project

- **Backend**: `backend/` - FastAPI Python application
  - `app/api/` - API route handlers (FastAPI routers)
  - `app/core/` - Configuration, security, database setup
  - `app/models/` - SQLModel database models
  - `app/schemas/` - Pydantic schemas for request/response validation
  - `app/services/` - Business logic, external API clients

- **Documentation**: `docs/` - All project documentation
- **Scripts**: `scripts/` - Automation and utility scripts

### File Naming Conventions
- **Frontend**: PascalCase for components (`TeamPitch.tsx`), camelCase for utilities (`api.ts`)
- **Backend**: snake_case for Python files (`auth.py`, `fpl_service.py`)
- **Models**: Singular nouns (`user.py`, `push_subscription.py`)
- **Services**: Descriptive names ending in `_service.py` (`fpl_service.py`, `notification_worker.py`)

---

## Technology Stack

### Frontend
- **Framework**: Next.js 16 (App Router)
- **UI Library**: React 19
- **Language**: TypeScript 5 (strict mode enabled)
- **Styling**: Tailwind CSS 4
- **HTTP Client**: Axios
- **Mobile**: Capacitor 7 (iOS/Android)

### Backend
- **Framework**: FastAPI
- **Language**: Python 3.11+
- **ORM**: SQLModel (SQLAlchemy-based)
- **Database**: PostgreSQL (production), SQLite (development)
- **Authentication**: JWT tokens with bcrypt password hashing
- **Validation**: Pydantic v2

---

## Code Style & Conventions

### Frontend (TypeScript/React)

#### Component Structure
```typescript
'use client'; // Required for client components

import { useState, useEffect } from 'react';
import { api } from '@/lib/api';

interface ComponentProps {
  // Props interface
}

export default function ComponentName({ prop1, prop2 }: ComponentProps) {
  // Component logic
  return (
    // JSX
  );
}
```

#### Rules:
1. **Always use TypeScript interfaces** for props, API responses, and data structures
2. **Use `'use client'` directive** for all client-side components that use hooks or browser APIs
3. **Import paths**: Use `@/` alias for `src/` directory imports
4. **Component naming**: PascalCase, descriptive names
5. **Function naming**: camelCase for functions, PascalCase for components
6. **Error handling**: Use try/catch blocks with proper error messages
7. **State management**: Prefer `useState` and `useEffect` hooks; use `useMemo` for expensive computations
8. **API calls**: Use the centralized `api` client from `@/lib/api.ts`

#### TypeScript Rules:
- **Strict mode**: Always enabled (`strict: true` in tsconfig.json)
- **Type everything**: No `any` types unless absolutely necessary
- **Interfaces over types**: Prefer interfaces for object shapes
- **Optional properties**: Use `?` for optional properties
- **Readonly**: Use `readonly` for immutable data structures

#### Styling Rules:
- **Tailwind CSS**: Use utility classes, prefer Tailwind over inline styles
- **Responsive design**: Mobile-first approach with Tailwind breakpoints
- **CSS Variables**: Use CSS variables for theme colors (e.g., `var(--pl-green)`)
- **Class organization**: Group related classes together (layout, spacing, colors, etc.)

### Backend (Python/FastAPI)

#### Code Structure
```python
from fastapi import APIRouter, Depends, HTTPException, status
from sqlmodel import Session, select
from app.core.database import get_session
from app.core.security import get_current_user
from app.models.user import User

router = APIRouter(prefix="/api/endpoint", tags=["Tag"])

@router.get("/", response_model=ResponseModel)
async def endpoint_name(
    param: str,
    current_user: User = Depends(get_current_user),
    session: Session = Depends(get_session)
):
    """Endpoint description"""
    # Implementation
    return result
```

#### Rules:
1. **Router organization**: One router per domain (auth, fpl, notifications, etc.)
2. **Dependency injection**: Use FastAPI's `Depends()` for database sessions and authentication
3. **Response models**: Always define Pydantic response models for type safety
4. **Error handling**: Use `HTTPException` with appropriate status codes
5. **Database sessions**: Always use `get_session()` dependency, never create sessions directly
6. **Async/await**: Use async functions for all endpoints
7. **Type hints**: Always include type hints for function parameters and return types
8. **Docstrings**: Include docstrings for all public functions and classes

#### Python Style:
- **PEP 8**: Follow PEP 8 style guide
- **Imports**: Group imports (stdlib, third-party, local) with blank lines
- **Naming**: snake_case for functions/variables, PascalCase for classes
- **Type hints**: Use Python 3.11+ type hints (`str`, `int`, `Optional[str]`, `List[Model]`)

#### Error Handling:
```python
try:
    # Operation
except SpecificException as e:
    print(f"[Module] Error message: {str(e)}")
    import traceback
    print(traceback.format_exc())
    raise HTTPException(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        detail="User-friendly error message"
    )
```

#### Logging:
- **Format**: Use `[Module]` prefix for log messages (e.g., `[Auth]`, `[DB]`, `[FPL]`)
- **Levels**: Use `print()` for now (consider migrating to proper logging later)
- **Error logging**: Always include error type and message, use traceback for debugging

---

## API Design

### Endpoint Naming
- **RESTful**: Use standard HTTP methods (GET, POST, PUT, DELETE)
- **URLs**: Use kebab-case for multi-word endpoints (`/api/fpl/my-team`)
- **Nested resources**: Use path parameters (`/api/fpl/team/{team_id}/picks/{gameweek}`)
- **Query parameters**: Use snake_case (`?gameweek=5&force_refresh=true`)

### Request/Response
- **Request validation**: Use Pydantic models for request bodies
- **Response models**: Always define response models for type safety and API docs
- **Status codes**: Use appropriate HTTP status codes (200, 201, 400, 401, 403, 404, 500, 503)
- **Error responses**: Consistent error format with `detail` field

### Authentication
- **JWT tokens**: Store in `localStorage` on frontend, send in `Authorization: Bearer <token>` header
- **Token expiration**: 7 days (configurable via `ACCESS_TOKEN_EXPIRE_MINUTES`)
- **Protected routes**: Use `get_current_user` dependency
- **Password hashing**: Always use `bcrypt` via `get_password_hash()` and `verify_password()`

---

## Database

### Models
- **SQLModel**: Use SQLModel for all database models
- **Naming**: Singular nouns (`User`, `PushSubscription`)
- **Table names**: Explicit `__tablename__` for clarity
- **Fields**: Use `Field()` for constraints, defaults, and relationships
- **Timestamps**: Include `created_at` and `updated_at` where appropriate

### Migrations
- **Auto-creation**: Tables are auto-created on startup via `create_db_and_tables()`
- **Schema changes**: Update models and restart application
- **Production**: Consider Alembic migrations for production deployments

### Queries
- **SQLModel queries**: Use `session.exec(select(Model).where(...))`
- **Session management**: Always use `get_session()` dependency, never create sessions manually
- **Transactions**: Use `session.commit()` after modifications
- **Error handling**: Handle connection errors gracefully with retries

---

## Environment Variables

### Frontend (`.env.local`)
```env
NEXT_PUBLIC_API_URL=http://localhost:8080
NEXT_PUBLIC_VAPID_PUBLIC_KEY=your_vapid_public_key
```

### Backend (`.env`)
```env
DATABASE_URL=sqlite:///./fpl_companion.db
SECRET_KEY=your-secret-key
FRONTEND_URL=http://localhost:3000
VAPID_PUBLIC_KEY=your_vapid_public_key
VAPID_PRIVATE_KEY=your_vapid_private_key
VAPID_EMAIL=your@email.com
FPL_ENCRYPTION_KEY=your_encryption_key
API_FOOTBALL_KEY=your_api_key
FOOTBALL_DATA_KEY=your_api_key
```

### Rules:
- **Never commit**: `.env` and `.env.local` files are gitignored
- **Documentation**: Document all required variables in `docs/deployment/DEPLOYMENT_ENV_VARS.md`
- **Defaults**: Provide sensible defaults in `Settings` class for development
- **Validation**: Validate required variables on startup

---

## Security

### Authentication & Authorization
- **Password hashing**: Always use `bcrypt` (via `get_password_hash()`)
- **JWT tokens**: Use secure secret keys, validate tokens on every request
- **Token storage**: Store tokens in `localStorage` (consider httpOnly cookies for production)
- **CORS**: Configure CORS properly for production (specific origins, not `*`)

### Data Protection
- **Sensitive data**: Encrypt FPL credentials using Fernet encryption
- **SQL injection**: Use SQLModel/SQLAlchemy queries, never raw SQL with user input
- **XSS**: Sanitize user input, use React's built-in XSS protection
- **CSRF**: FastAPI handles CSRF protection for forms

### Secrets Management
- **Environment variables**: Never hardcode secrets
- **Encryption keys**: Generate secure keys for encryption
- **API keys**: Store in environment variables, never in code

---

## Testing

### Test Structure
- **Backend**: Use pytest for Python tests
- **Frontend**: Use Next.js built-in testing (consider Jest/Vitest)
- **Test agents**: Use `scripts/test_agent.sh` or `scripts/ai_test_agent.py` for automated testing

### Testing Rules:
1. **Run tests before commits**: Always run tests before committing changes
2. **Test coverage**: Aim for high test coverage on critical paths
3. **Test isolation**: Each test should be independent
4. **Mock external APIs**: Mock FPL API and external services in tests

---

## Mobile Development (Capacitor)

### Build Process
```bash
cd frontend
npm run mobile:build  # Build Next.js and sync to native projects
npm run ios:build     # Open in Xcode
npm run android:build # Open in Android Studio
```

### Rules:
1. **API URL**: Configure `NEXT_PUBLIC_API_URL` for mobile builds
2. **Capacitor sync**: Run `npx cap sync` after adding new plugins
3. **Native code**: Only modify native code when necessary, prefer web solutions
4. **Platform detection**: Use `Capacitor.isNativePlatform()` to detect mobile

---

## Git & Version Control

### Commit Messages
- **Format**: Use descriptive commit messages
- **Prefixes**: Consider using prefixes (feat:, fix:, docs:, refactor:)
- **Scope**: Include affected area (frontend, backend, docs)

### Branching
- **Main branch**: `main` or `master`
- **Feature branches**: `feature/description`
- **Bug fixes**: `fix/description`

### Rules:
- **Never commit**: `.env` files, `node_modules/`, `venv/`, `__pycache__/`, `.next/`, `out/`
- **Review before commit**: Review changes before committing
- **Test before commit**: Run tests before committing

---

## Development Workflow

### Completion Checklist
Before marking development as complete, ensure:
1. [ ] All code follows project conventions and style guidelines
2. [ ] TypeScript/Python types are correct and complete
3. [ ] Error handling is implemented properly
4. [ ] Tests pass (run `./scripts/test_agent.sh` or `python3 scripts/ai_test_agent.py`)
5. [ ] Code is properly formatted and linted
6. [ ] Documentation is updated (if applicable)
7. [ ] No secrets or sensitive data are committed
8. [ ] All changes are committed with descriptive commit messages

### Pushing to GitHub
**MANDATORY**: After completing development work:

1. **Commit all changes**:
   ```bash
   git add .
   git commit -m "feat: description of changes"
   ```

2. **Push to GitHub**:
   ```bash
   git push origin <branch-name>
   ```
   - If working on a feature branch, push the feature branch
   - If working directly on main, push to main (only if appropriate)

3. **Notify QA Agent**:
   - After pushing to GitHub, **ALWAYS notify the QA Agent** that the code is ready for testing
   - Include:
     - What was developed/changed
     - Which branch was pushed
     - Any specific areas that need testing
     - Any known issues or limitations

### Example Completion Message
```
Development complete ✅

**Changes:**
- Added new transfer recommendation feature
- Updated API endpoints for team selection
- Fixed bug in player stats display

**Branch:** feature/transfer-recommendations
**Status:** Pushed to GitHub, ready for QA testing

**Testing Notes:**
- Please test transfer recommendations with various team configurations
- Verify API endpoints work with both authenticated and unauthenticated users
- Check mobile responsiveness on iOS and Android
```

### Workflow Integration
This workflow integrates with the project's agent system:
- **Developer Agent** → Completes development → Pushes to GitHub → Notifies QA Agent
- **QA Agent** → Tests implementation → Reports back to Developer if issues found
- **Developer Agent** → Fixes issues → Pushes fixes → Notifies QA again

---

## Documentation

### Code Documentation
- **Docstrings**: Include docstrings for all public functions and classes
- **Comments**: Add comments for complex logic or non-obvious decisions
- **Type hints**: Use type hints as documentation

### Project Documentation
- **Location**: All documentation in `docs/` directory
- **Format**: Markdown (`.md`)
- **Structure**: Organize by topic (setup, deployment, testing, etc.)
- **Keep updated**: Update documentation when making changes

---

## Performance

### Frontend
- **Code splitting**: Use Next.js automatic code splitting
- **Image optimization**: Use Next.js Image component for images
- **Memoization**: Use `useMemo` and `useCallback` for expensive operations
- **Lazy loading**: Lazy load heavy components

### Backend
- **Database queries**: Optimize queries, use indexes where appropriate
- **Caching**: Consider Redis caching for FPL API data
- **Async operations**: Use async/await for I/O operations
- **Connection pooling**: Use connection pooling for database

---

## Error Handling

### Frontend
```typescript
try {
  const response = await api.get('/endpoint');
  return response.data;
} catch (err: any) {
  const errorMessage = err.response?.data?.detail || 'Failed to load data';
  setError(errorMessage);
  // Show user-friendly error message
}
```

### Backend
```python
try:
    # Operation
except SpecificException as e:
    print(f"[Module] Error: {str(e)}")
    raise HTTPException(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        detail="User-friendly error message"
    )
```

### Rules:
- **User-friendly messages**: Always show user-friendly error messages
- **Logging**: Log detailed errors for debugging
- **Error boundaries**: Use React error boundaries for component errors
- **Graceful degradation**: Handle errors gracefully, don't crash the app

---

## Code Review Checklist

Before submitting code, ensure:
- [ ] Code follows style conventions
- [ ] TypeScript/Python types are correct
- [ ] Error handling is implemented
- [ ] Tests pass (if applicable)
- [ ] Documentation is updated
- [ ] Environment variables are documented
- [ ] No secrets are committed
- [ ] Code is properly formatted
- [ ] No console.logs in production code (use proper logging)
- [ ] CORS is configured correctly
- [ ] Authentication is implemented for protected routes
- [ ] **All changes are committed and pushed to GitHub**
- [ ] **QA Agent has been notified that code is ready for testing**

---

## Common Patterns

### API Client Pattern (Frontend)
```typescript
export const apiModule = {
  getData: async (id: number) => {
    const response = await api.get(`/api/module/${id}`);
    return response.data;
  },
  
  createData: async (data: CreateData) => {
    const response = await api.post('/api/module', data);
    return response.data;
  },
};
```

### Service Pattern (Backend)
```python
class ServiceName:
    def __init__(self):
        # Initialize service
    
    async def method_name(self, param: str) -> Result:
        """Method description"""
        # Implementation
        return result

service_instance = ServiceName()
```

### Component Pattern (Frontend)
```typescript
interface ComponentProps {
  prop1: string;
  prop2?: number;
}

export default function Component({ prop1, prop2 }: ComponentProps) {
  const [state, setState] = useState<string>('');
  
  useEffect(() => {
    // Side effects
  }, [dependencies]);
  
  return (
    <div>
      {/* JSX */}
    </div>
  );
}
```

---

## Best Practices

1. **Keep it simple**: Prefer simple solutions over complex ones
2. **DRY principle**: Don't repeat yourself, extract common code
3. **Single responsibility**: Each function/component should do one thing
4. **Type safety**: Use TypeScript/Python types to catch errors early
5. **Error handling**: Always handle errors gracefully
6. **Security first**: Never trust user input, always validate
7. **Performance**: Consider performance implications of code changes
8. **Accessibility**: Ensure UI is accessible (WCAG AA compliance)
9. **Mobile-first**: Design for mobile, enhance for desktop
10. **Documentation**: Document complex logic and decisions

---

## When in Doubt

1. **Check existing code**: Look at similar implementations in the codebase
2. **Follow patterns**: Follow established patterns in the project
3. **Ask questions**: If unsure, ask for clarification
4. **Document decisions**: Document why you made certain choices
5. **Test thoroughly**: Test your changes before committing

---

## Updates

This document should be updated as the project evolves. When adding new conventions or patterns, update this document accordingly.

**Last Updated**: 2025-01-27
